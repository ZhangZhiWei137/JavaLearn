广义上我们将内部类分为四种：
	成员内部类、
	静态内部类、
	局部（方法）内部类、
	匿名内部类。
	
优点	
	1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
	2、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
	3、内部类提供了更好的封装，除了该外围类，其他类都不能访问。
	4、创建内部类对象的时刻并不依赖于外围类对象的创建。
	5.间接解决类无法多继承引起的一系列问题
	
//////////////////////////////////////////////////////
成员内部类:
	小结：【成员内部类当成Outer的成员信息存在 】
	可以是任何的访问修饰符。
	内部类的内部不能有静态信息。
	内部类也是类,该继承继承，该重写重写，该重载重载，this和super随便用。
	外部类如何访问内部类信息，必须new之后打点访问。
	内部类可以直接使用外部类的任何信息，如果属性或者方法发生冲突，调用外部类.this.属性或者方法。
	其它类如何访问内部类：


//////////////////////////////////////////////////////
静态内部类:
	小结【和成员内部类对比理解（区别异同）】
	内部可以包含任意的信息。
	静态内部类的方法只能访问外部类的static关联的信息。
	利用 外部类.内部类 引用=new 外部类.内部类(); 然后利用引用.成员信息(属性、方法)调用。
	访问内部类的静态信息，直接外部类.内部类.静态信息就可以了。
	静态内部类可以独立存在，不依赖于其他外围类。

//////////////////////////////////////////////////////
局部（方法）内部类:
	小结【局部内有很多局限，应注意作用域】
	类前不能有访问修饰符。
	仅在此方法内使用。
	无法创造静态信息。
	可以直接访问方法内的局部变量和参数（有限制，下面详谈），但是不能更改。
	可以随意的访问外部类的任何信息。
	
//////////////////////////////////////////////////////
匿名内部类:
	小结【匿名内部类常常被用来重写某个或某些方法】
	匿名内部类是没有访问修饰符的。
	使用匿名内部类时，这个new之后的类首先是要存在的，其次我们要重写new后的类的某个或某些方法。
	匿名内部类访问方法参数时也有和局部内部类同样的限制。
	匿名内部类没有构造方法。
